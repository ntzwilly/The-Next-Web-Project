{"version":3,"file":"SpanParser.js","sourceRoot":"","sources":["../../../AutoCollection/diagnostic-channel/SpanParser.ts"],"names":[],"mappings":";;;;;;;;;;AAAA,4DAA4D;AAC5D,oFAAoF;AACpF,oEAA2D;AAE3D,wDAA0D;AAE1D,8BAA8B,UAAkC;IAC5D,IAAM,aAAa,gBAAQ,UAAU,CAAE,CAAC;IACxC,MAAM,CAAC,IAAI,CAAC,SAAS,CAAC,aAAa,CAAC,CAAC,OAAO,CAAC,UAAA,GAAG;QAC5C,OAAO,aAAa,CAAC,GAAG,CAAC,CAAC;IAC9B,CAAC,CAAC,CAAC;IACH,MAAM,CAAC,aAAa,CAAA;AACxB,CAAC;AAED,iCAAwC,IAAU;IAC9C,IAAM,EAAE,GAAG,MAAI,IAAI,CAAC,OAAO,EAAE,CAAC,OAAO,SAAI,IAAI,CAAC,OAAO,EAAE,CAAC,MAAM,MAAG,CAAC;IAClE,IAAM,QAAQ,GAAG,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC,GAAG,GAAG,GAAG,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC,GAAG,GAAG,CAAC,CAAC;IAC/E,IAAM,MAAM,GAAY,CAAC,CAAC,IAAI,CAAC,UAAU,CAAC,SAAS,IAAI,EAAE,CAAC,CAAC,WAAW,EAAE,KAAK,SAAS,CAAC,kBAAkB,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC,IAAI,CAAC,UAAU,CAAC,SAAS,CAAC,aAAa,CAAC,OAAO,CAAC,CAAC,CAAC;IACxK,IAAM,MAAM,GAAY,CAAC,IAAI,CAAC,UAAU,CAAC,SAAS,IAAI,EAAE,CAAC,CAAC,WAAW,EAAE,KAAK,SAAS,CAAC,kBAAkB,CAAC,IAAI,CAAC;IAC9G,EAAE,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC;QACT,4BAA4B;QAC5B,IAAM,MAAM,GAAG,IAAI,CAAC,UAAU,CAAC,SAAS,CAAC,aAAa,CAAC,UAAU,CAAC,IAAI,KAAK,CAAC;QAC5E,IAAM,GAAG,GAAG,IAAI,GAAG,CAAC,IAAI,CAAC,UAAU,CAAC,SAAS,CAAC,aAAa,CAAC,OAAO,CAAC,CAAC,CAAC;QACtE,IAAM,IAAI,GAAG,IAAI,CAAC,UAAU,CAAC,SAAS,CAAC,aAAa,CAAC,QAAQ,CAAC,IAAI,GAAG,CAAC,IAAI,CAAC;QAC3E,IAAM,IAAI,GAAG,IAAI,CAAC,UAAU,CAAC,SAAS,CAAC,aAAa,CAAC,QAAQ,CAAC,IAAI,GAAG,CAAC,IAAI,IAAI,IAAI,CAAC;QACnF,IAAM,QAAQ,GAAG,GAAG,CAAC,QAAQ,IAAI,GAAG,CAAC;QAErC,oCAAoC;QACpC,IAAM,MAAI,GAAM,MAAM,SAAI,QAAU,CAAC;QACrC,IAAM,kBAAkB,GAAG,SAAS,CAAC,kBAAkB,CAAC,IAAI,CAAC;QAC7D,IAAM,MAAM,GAAG,IAAI,GAAM,IAAI,SAAI,IAAM,GAAG,IAAI,CAAC;QAC/C,IAAM,IAAI,GAAG,GAAG,CAAC,QAAQ,EAAE,CAAC;QAC5B,IAAM,UAAU,GAAG,IAAI,CAAC,UAAU,CAAC,SAAS,CAAC,aAAa,CAAC,cAAc,CAAC,IAAI,IAAI,CAAC,MAAM,CAAC,IAAI,IAAI,CAAC,CAAC;QACpG,IAAM,OAAO,GAAG,UAAU,GAAG,GAAG,CAAC,CAAC,YAAY;QAC9C,MAAM,CAAC;YACH,EAAE,IAAA,EAAE,IAAI,QAAA,EAAE,kBAAkB,oBAAA;YAC5B,MAAM,QAAA,EAAE,IAAI,MAAA;YACZ,OAAO,SAAA,EAAE,QAAQ,UAAA;YACjB,GAAG,EAAE,IAAI;YACT,UAAU,EAAE,MAAM,CAAC,UAAU,CAAC;YAC9B,UAAU,EAAE,oBAAoB,CAAC,IAAI,CAAC,UAAU,CAAC;SACpD,CAAC;IACN,CAAC;IAAC,IAAI,CAAC,EAAE,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC;QAChB,IAAM,MAAM,GAAG,IAAI,CAAC,UAAU,CAAC,SAAS,CAAC,aAAa,CAAC,UAAU,CAAC,IAAI,KAAK,CAAC;QAC5E,IAAM,OAAO,GAAG,IAAI,CAAC,UAAU,CAAC,SAAS,CAAC,aAAa,CAAC,WAAW,CAAC,CAAC;QACrE,IAAM,MAAI,GAAG,OAAO,GAAM,MAAM,SAAI,OAAS,GAAG,IAAI,CAAC,IAAI,CAAC;QAC1D,MAAM,CAAC;YACH,EAAE,IAAA,EAAE,QAAQ,UAAA,EAAE,IAAI,QAAA;YAClB,MAAM,EAAE,OAAO;YACf,IAAI,EAAE,OAAO,IAAI,MAAI;YACrB,GAAG,EAAE,OAAO,IAAI,MAAI;YACpB,kBAAkB,EAAE,SAAS,CAAC,kBAAkB,CAAC,IAAI;YACrD,UAAU,EAAE,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC,IAAI,IAAI,CAAC,CAAC;YACzC,OAAO,EAAE,IAAI,CAAC,MAAM,CAAC,IAAI,KAAK,CAAC;YAC/B,UAAU,EAAE,oBAAoB,CAAC,IAAI,CAAC,UAAU,CAAC;SACpD,CAAA;IACL,CAAC;IAAC,IAAI,CAAC,CAAC;QACJ,IAAM,MAAI,GAAG,IAAI,CAAC,IAAI,CAAC;QACvB,IAAM,KAAK,GAAG,IAAI,CAAC,KAAK,IAAI,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,UAAA,IAAI;YAC3C,MAAM,CAAC;gBACH,YAAY,EAAE,IAAI,CAAC,WAAW,CAAC,OAAO;gBACtC,EAAE,EAAE,IAAI,CAAC,WAAW,CAAC,MAAM;aAC9B,CAAC;QACN,CAAC,CAAC,CAAC;QACH,MAAM,CAAC;YACH,EAAE,IAAA,EAAE,QAAQ,UAAA,EAAE,IAAI,QAAA;YAClB,MAAM,EAAE,IAAI,CAAC,UAAU,CAAC,cAAc,CAAC;YACvC,IAAI,EAAE,IAAI,CAAC,UAAU,CAAC,cAAc,CAAC,IAAI,MAAI;YAC7C,GAAG,EAAE,IAAI,CAAC,UAAU,CAAC,cAAc,CAAC,IAAI,MAAI;YAC5C,kBAAkB,EAAE,IAAI,CAAC,IAAI,KAAK,iCAAQ,CAAC,QAAQ,GAAG,SAAS,CAAC,kBAAkB,CAAC,MAAM,GAAG,CAAC,IAAI,CAAC,UAAU,CAAC,SAAS,IAAI,IAAI,CAAC,IAAI,CAAC;YACpI,UAAU,EAAE,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC,IAAI,IAAI,CAAC,CAAC;YACzC,OAAO,EAAE,IAAI,CAAC,MAAM,CAAC,IAAI,KAAK,CAAC;YAC/B,UAAU,eACH,oBAAoB,CAAC,IAAI,CAAC,UAAU,CAAC,IACxC,WAAW,EAAE,KAAK,IAAI,SAAS,GAClC;SACJ,CAAC;IACN,CAAC;AACL,CAAC;AAhED,0DAgEC","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT license. See LICENSE file in the project root for details.\r\nimport { Span, SpanKind } from \"../AsyncHooksScopeManager\";\r\nimport * as Contracts from \"../../Declarations/Contracts\";\r\nimport * as Constants from \"../../Declarations/Constants\";\r\n\r\nfunction filterSpanAttributes(attributes: Record<string, string>) {\r\n    const newAttributes = { ...attributes };\r\n    Object.keys(Constants.SpanAttribute).forEach(key => {\r\n        delete newAttributes[key];\r\n    });\r\n    return newAttributes\r\n}\r\n\r\nexport function spanToTelemetryContract(span: Span): (Contracts.DependencyTelemetry & Contracts.RequestTelemetry) & Contracts.Identified {\r\n    const id = `|${span.context().traceId}.${span.context().spanId}.`;\r\n    const duration = Math.round(span._duration[0] * 1e3 + span._duration[1] / 1e6);\r\n    const isHttp: boolean = ((span.attributes.component || \"\").toUpperCase() === Constants.DependencyTypeName.Http) || (!!span.attributes[Constants.SpanAttribute.HttpUrl]);\r\n    const isGrpc: boolean = (span.attributes.component || \"\").toLowerCase() === Constants.DependencyTypeName.Grpc;\r\n    if (isHttp) {\r\n        // Read http span attributes\r\n        const method = span.attributes[Constants.SpanAttribute.HttpMethod] || \"GET\";\r\n        const url = new URL(span.attributes[Constants.SpanAttribute.HttpUrl]);\r\n        const host = span.attributes[Constants.SpanAttribute.HttpHost] || url.host;\r\n        const port = span.attributes[Constants.SpanAttribute.HttpPort] || url.port || null;\r\n        const pathname = url.pathname || \"/\";\r\n\r\n        // Translate to AI Dependency format\r\n        const name = `${method} ${pathname}`;\r\n        const dependencyTypeName = Constants.DependencyTypeName.Http;\r\n        const target = port ? `${host}:${port}` : host;\r\n        const data = url.toString();\r\n        const resultCode = span.attributes[Constants.SpanAttribute.HttpStatusCode] || span.status.code || 0;\r\n        const success = resultCode < 400; // Status.OK\r\n        return {\r\n            id, name, dependencyTypeName,\r\n            target, data,\r\n            success, duration,\r\n            url: data,\r\n            resultCode: String(resultCode),\r\n            properties: filterSpanAttributes(span.attributes)\r\n        };\r\n    } else if (isGrpc) {\r\n        const method = span.attributes[Constants.SpanAttribute.GrpcMethod] || \"rpc\";\r\n        const service = span.attributes[Constants.SpanAttribute.GrpcService];\r\n        const name = service ? `${method} ${service}` : span.name;\r\n        return {\r\n            id, duration, name,\r\n            target: service,\r\n            data: service || name,\r\n            url: service || name,\r\n            dependencyTypeName: Constants.DependencyTypeName.Grpc,\r\n            resultCode: String(span.status.code || 0),\r\n            success: span.status.code === 0,\r\n            properties: filterSpanAttributes(span.attributes),\r\n        }\r\n    } else {\r\n        const name = span.name;\r\n        const links = span.links && span.links.map(link => {\r\n            return {\r\n                operation_Id: link.spanContext.traceId,\r\n                id: link.spanContext.spanId\r\n            };\r\n        });\r\n        return {\r\n            id, duration, name,\r\n            target: span.attributes[\"peer.address\"],\r\n            data: span.attributes[\"peer.address\"] || name,\r\n            url: span.attributes[\"peer.address\"] || name,\r\n            dependencyTypeName: span.kind === SpanKind.INTERNAL ? Constants.DependencyTypeName.InProc : (span.attributes.component || span.name),\r\n            resultCode: String(span.status.code || 0),\r\n            success: span.status.code === 0,\r\n            properties: {\r\n                ...filterSpanAttributes(span.attributes),\r\n                \"_MS.links\": links || undefined\r\n            },\r\n        };\r\n    }\r\n}\r\n"]}